package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// EventApplication represents a row from 'public.EventApplications'.
type EventApplication struct {
	EventApplicationID int           `json:"EventApplicationID"` // EventApplicationID
	UserFk             sql.NullInt64 `json:"UserFk"`             // UserFk
	DateCreated        sql.NullTime  `json:"DateCreated"`        // DateCreated
	OrgEventFk         sql.NullInt64 `json:"OrgEventFk"`         // OrgEventFk
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the EventApplication exists in the database.
func (ea *EventApplication) Exists() bool {
	return ea._exists
}

// Deleted returns true when the EventApplication has been marked for deletion from
// the database.
func (ea *EventApplication) Deleted() bool {
	return ea._deleted
}

// Insert inserts the EventApplication to the database.
func (ea *EventApplication) Insert(ctx context.Context, db DB) error {
	switch {
	case ea._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ea._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.EventApplications (` +
		`UserFk, DateCreated, OrgEventFk` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING EventApplicationID`
	// run
	logf(sqlstr, ea.UserFk, ea.DateCreated, ea.OrgEventFk)
	if err := db.QueryRowContext(ctx, sqlstr, ea.UserFk, ea.DateCreated, ea.OrgEventFk).Scan(&ea.EventApplicationID); err != nil {
		return logerror(err)
	}
	// set exists
	ea._exists = true
	return nil
}

// Update updates a EventApplication in the database.
func (ea *EventApplication) Update(ctx context.Context, db DB) error {
	switch {
	case !ea._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ea._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.EventApplications SET ` +
		`UserFk = $1, DateCreated = $2, OrgEventFk = $3 ` +
		`WHERE EventApplicationID = $4`
	// run
	logf(sqlstr, ea.UserFk, ea.DateCreated, ea.OrgEventFk, ea.EventApplicationID)
	if _, err := db.ExecContext(ctx, sqlstr, ea.UserFk, ea.DateCreated, ea.OrgEventFk, ea.EventApplicationID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the EventApplication to the database.
func (ea *EventApplication) Save(ctx context.Context, db DB) error {
	if ea.Exists() {
		return ea.Update(ctx, db)
	}
	return ea.Insert(ctx, db)
}

// Upsert performs an upsert for EventApplication.
func (ea *EventApplication) Upsert(ctx context.Context, db DB) error {
	switch {
	case ea._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.EventApplications (` +
		`EventApplicationID, UserFk, DateCreated, OrgEventFk` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (EventApplicationID) DO ` +
		`UPDATE SET ` +
		`UserFk = EXCLUDED.UserFk, DateCreated = EXCLUDED.DateCreated, OrgEventFk = EXCLUDED.OrgEventFk `
	// run
	logf(sqlstr, ea.EventApplicationID, ea.UserFk, ea.DateCreated, ea.OrgEventFk)
	if _, err := db.ExecContext(ctx, sqlstr, ea.EventApplicationID, ea.UserFk, ea.DateCreated, ea.OrgEventFk); err != nil {
		return logerror(err)
	}
	// set exists
	ea._exists = true
	return nil
}

// Delete deletes the EventApplication from the database.
func (ea *EventApplication) Delete(ctx context.Context, db DB) error {
	switch {
	case !ea._exists: // doesn't exist
		return nil
	case ea._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.EventApplications ` +
		`WHERE EventApplicationID = $1`
	// run
	logf(sqlstr, ea.EventApplicationID)
	if _, err := db.ExecContext(ctx, sqlstr, ea.EventApplicationID); err != nil {
		return logerror(err)
	}
	// set deleted
	ea._deleted = true
	return nil
}

// EventApplicationByEventApplicationID retrieves a row from 'public.EventApplications' as a EventApplication.
//
// Generated from index 'EventApplications_pkey'.
func EventApplicationByEventApplicationID(ctx context.Context, db DB, eventApplicationID int) (*EventApplication, error) {
	// query
	const sqlstr = `SELECT ` +
		`EventApplicationID, UserFk, DateCreated, OrgEventFk ` +
		`FROM public.EventApplications ` +
		`WHERE EventApplicationID = $1`
	// run
	logf(sqlstr, eventApplicationID)
	ea := EventApplication{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, eventApplicationID).Scan(&ea.EventApplicationID, &ea.UserFk, &ea.DateCreated, &ea.OrgEventFk); err != nil {
		return nil, logerror(err)
	}
	return &ea, nil
}

// OrganizationEvent returns the OrganizationEvent associated with the EventApplication's (OrgEventFk).
//
// Generated from foreign key 'EventApplications_OrgEventFk_fkey'.
func (ea *EventApplication) OrganizationEvent(ctx context.Context, db DB) (*OrganizationEvent, error) {
	return OrganizationEventByOrganizationEventID(ctx, db, int(ea.OrgEventFk.Int64))
}

// User returns the User associated with the EventApplication's (UserFk).
//
// Generated from foreign key 'EventApplications_UserFk_fkey'.
func (ea *EventApplication) User(ctx context.Context, db DB) (*User, error) {
	return UserByUserID(ctx, db, int(ea.UserFk.Int64))
}
