package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// Organization represents a row from 'public.organizations'.
type Organization struct {
	Organizationid   int    `json:"organizationid"`   // organizationid
	Name             string `json:"name"`             // name
	Description      string `json:"description"`      // description
	Organizationuuid string `json:"organizationuuid"` // organizationuuid
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Organization exists in the database.
func (o *Organization) Exists() bool {
	return o._exists
}

// Deleted returns true when the Organization has been marked for deletion from
// the database.
func (o *Organization) Deleted() bool {
	return o._deleted
}

// Insert inserts the Organization to the database.
func (o *Organization) Insert(ctx context.Context, db DB) error {
	switch {
	case o._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case o._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.organizations (` +
		`name, description, organizationuuid` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING organizationid`
	// run
	logf(sqlstr, o.Name, o.Description, o.Organizationuuid)
	if err := db.QueryRowContext(ctx, sqlstr, o.Name, o.Description, o.Organizationuuid).Scan(&o.Organizationid); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Update updates a Organization in the database.
func (o *Organization) Update(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case o._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.organizations SET ` +
		`name = $1, description = $2, organizationuuid = $3 ` +
		`WHERE organizationid = $4`
	// run
	logf(sqlstr, o.Name, o.Description, o.Organizationuuid, o.Organizationid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Name, o.Description, o.Organizationuuid, o.Organizationid); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Organization to the database.
func (o *Organization) Save(ctx context.Context, db DB) error {
	if o.Exists() {
		return o.Update(ctx, db)
	}
	return o.Insert(ctx, db)
}

// Upsert performs an upsert for Organization.
func (o *Organization) Upsert(ctx context.Context, db DB) error {
	switch {
	case o._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.organizations (` +
		`organizationid, name, description, organizationuuid` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (organizationid) DO ` +
		`UPDATE SET ` +
		`name = EXCLUDED.name, description = EXCLUDED.description, organizationuuid = EXCLUDED.organizationuuid `
	// run
	logf(sqlstr, o.Organizationid, o.Name, o.Description, o.Organizationuuid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Organizationid, o.Name, o.Description, o.Organizationuuid); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Delete deletes the Organization from the database.
func (o *Organization) Delete(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return nil
	case o._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.organizations ` +
		`WHERE organizationid = $1`
	// run
	logf(sqlstr, o.Organizationid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Organizationid); err != nil {
		return logerror(err)
	}
	// set deleted
	o._deleted = true
	return nil
}

// OrganizationByOrganizationid retrieves a row from 'public.organizations' as a Organization.
//
// Generated from index 'organizations_pkey'.
func OrganizationByOrganizationid(ctx context.Context, db DB, organizationid int) (*Organization, error) {
	// query
	const sqlstr = `SELECT ` +
		`organizationid, name, description, organizationuuid ` +
		`FROM public.organizations ` +
		`WHERE organizationid = $1`
	// run
	logf(sqlstr, organizationid)
	o := Organization{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, organizationid).Scan(&o.Organizationid, &o.Name, &o.Description, &o.Organizationuuid); err != nil {
		return nil, logerror(err)
	}
	return &o, nil
}
