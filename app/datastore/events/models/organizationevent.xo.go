package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// Organizationevent represents a row from 'public.organizationevents'.
type Organizationevent struct {
	Organizationeventid int     `json:"organizationeventid"` // organizationeventid
	Name                string  `json:"name"`                // name
	Latitude            float64 `json:"latitude"`            // latitude
	Longitude           float64 `json:"longitude"`           // longitude
	City                string  `json:"city"`                // city
	State               string  `json:"state"`               // state
	Orgfk               int     `json:"orgfk"`               // orgfk
	Capacity            int     `json:"capacity"`            // capacity
	Attending           int     `json:"attending"`           // attending
	Eventuuid           string  `json:"eventuuid"`           // eventuuid
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Organizationevent exists in the database.
func (o *Organizationevent) Exists() bool {
	return o._exists
}

// Deleted returns true when the Organizationevent has been marked for deletion from
// the database.
func (o *Organizationevent) Deleted() bool {
	return o._deleted
}

// Insert inserts the Organizationevent to the database.
func (o *Organizationevent) Insert(ctx context.Context, db DB) error {
	switch {
	case o._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case o._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.organizationevents (` +
		`name, latitude, longitude, city, state, orgfk, capacity, attending, eventuuid` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING organizationeventid`
	// run
	logf(sqlstr, o.Name, o.Latitude, o.Longitude, o.City, o.State, o.Orgfk, o.Capacity, o.Attending, o.Eventuuid)
	if err := db.QueryRowContext(ctx, sqlstr, o.Name, o.Latitude, o.Longitude, o.City, o.State, o.Orgfk, o.Capacity, o.Attending, o.Eventuuid).Scan(&o.Organizationeventid); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Update updates a Organizationevent in the database.
func (o *Organizationevent) Update(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case o._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.organizationevents SET ` +
		`name = $1, latitude = $2, longitude = $3, city = $4, state = $5, orgfk = $6, capacity = $7, attending = $8, eventuuid = $9 ` +
		`WHERE organizationeventid = $10`
	// run
	logf(sqlstr, o.Name, o.Latitude, o.Longitude, o.City, o.State, o.Orgfk, o.Capacity, o.Attending, o.Eventuuid, o.Organizationeventid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Name, o.Latitude, o.Longitude, o.City, o.State, o.Orgfk, o.Capacity, o.Attending, o.Eventuuid, o.Organizationeventid); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Organizationevent to the database.
func (o *Organizationevent) Save(ctx context.Context, db DB) error {
	if o.Exists() {
		return o.Update(ctx, db)
	}
	return o.Insert(ctx, db)
}

// Upsert performs an upsert for Organizationevent.
func (o *Organizationevent) Upsert(ctx context.Context, db DB) error {
	switch {
	case o._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.organizationevents (` +
		`organizationeventid, name, latitude, longitude, city, state, orgfk, capacity, attending, eventuuid` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (organizationeventid) DO ` +
		`UPDATE SET ` +
		`name = EXCLUDED.name, latitude = EXCLUDED.latitude, longitude = EXCLUDED.longitude, city = EXCLUDED.city, state = EXCLUDED.state, orgfk = EXCLUDED.orgfk, capacity = EXCLUDED.capacity, attending = EXCLUDED.attending, eventuuid = EXCLUDED.eventuuid `
	// run
	logf(sqlstr, o.Organizationeventid, o.Name, o.Latitude, o.Longitude, o.City, o.State, o.Orgfk, o.Capacity, o.Attending, o.Eventuuid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Organizationeventid, o.Name, o.Latitude, o.Longitude, o.City, o.State, o.Orgfk, o.Capacity, o.Attending, o.Eventuuid); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Delete deletes the Organizationevent from the database.
func (o *Organizationevent) Delete(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return nil
	case o._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.organizationevents ` +
		`WHERE organizationeventid = $1`
	// run
	logf(sqlstr, o.Organizationeventid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Organizationeventid); err != nil {
		return logerror(err)
	}
	// set deleted
	o._deleted = true
	return nil
}

// OrganizationeventByEventuuid retrieves a row from 'public.organizationevents' as a Organizationevent.
//
// Generated from index 'organizationeventindex'.
func OrganizationeventByEventuuid(ctx context.Context, db DB, eventuuid string) (*Organizationevent, error) {
	// query
	const sqlstr = `SELECT ` +
		`organizationeventid, name, latitude, longitude, city, state, orgfk, capacity, attending, eventuuid ` +
		`FROM public.organizationevents ` +
		`WHERE eventuuid = $1`
	// run
	logf(sqlstr, eventuuid)
	o := Organizationevent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, eventuuid).Scan(&o.Organizationeventid, &o.Name, &o.Latitude, &o.Longitude, &o.City, &o.State, &o.Orgfk, &o.Capacity, &o.Attending, &o.Eventuuid); err != nil {
		return nil, logerror(err)
	}
	return &o, nil
}

// OrganizationeventByOrganizationeventid retrieves a row from 'public.organizationevents' as a Organizationevent.
//
// Generated from index 'organizationevents_pkey'.
func OrganizationeventByOrganizationeventid(ctx context.Context, db DB, organizationeventid int) (*Organizationevent, error) {
	// query
	const sqlstr = `SELECT ` +
		`organizationeventid, name, latitude, longitude, city, state, orgfk, capacity, attending, eventuuid ` +
		`FROM public.organizationevents ` +
		`WHERE organizationeventid = $1`
	// run
	logf(sqlstr, organizationeventid)
	o := Organizationevent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, organizationeventid).Scan(&o.Organizationeventid, &o.Name, &o.Latitude, &o.Longitude, &o.City, &o.State, &o.Orgfk, &o.Capacity, &o.Attending, &o.Eventuuid); err != nil {
		return nil, logerror(err)
	}
	return &o, nil
}

// Organization returns the Organization associated with the Organizationevent's (Orgfk).
//
// Generated from foreign key 'organizationevents_orgfk_fkey'.
func (o *Organizationevent) Organization(ctx context.Context, db DB) (*Organization, error) {
	return OrganizationByOrganizationid(ctx, db, o.Orgfk)
}
