package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// OrganizationEvent represents a row from 'public.OrganizationEvents'.
type OrganizationEvent struct {
	OrganizationEventID int     `json:"OrganizationEventID"` // OrganizationEventID
	Name                string  `json:"Name"`                // Name
	Latitude            float64 `json:"Latitude"`            // Latitude
	Longitude           float64 `json:"Longitude"`           // Longitude
	City                string  `json:"City"`                // City
	State               string  `json:"State"`               // State
	OrgFk               int     `json:"OrgFk"`               // OrgFk
	Capacity            int     `json:"Capacity"`            // Capacity
	Attending           int     `json:"Attending"`           // Attending
	EventUUID           string  `json:"EventUuid"`           // EventUuid
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the OrganizationEvent exists in the database.
func (oe *OrganizationEvent) Exists() bool {
	return oe._exists
}

// Deleted returns true when the OrganizationEvent has been marked for deletion from
// the database.
func (oe *OrganizationEvent) Deleted() bool {
	return oe._deleted
}

// Insert inserts the OrganizationEvent to the database.
func (oe *OrganizationEvent) Insert(ctx context.Context, db DB) error {
	switch {
	case oe._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case oe._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.OrganizationEvents (` +
		`Name, Latitude, Longitude, City, State, OrgFk, Capacity, Attending, EventUuid` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING OrganizationEventID`
	// run
	logf(sqlstr, oe.Name, oe.Latitude, oe.Longitude, oe.City, oe.State, oe.OrgFk, oe.Capacity, oe.Attending, oe.EventUUID)
	if err := db.QueryRowContext(ctx, sqlstr, oe.Name, oe.Latitude, oe.Longitude, oe.City, oe.State, oe.OrgFk, oe.Capacity, oe.Attending, oe.EventUUID).Scan(&oe.OrganizationEventID); err != nil {
		return logerror(err)
	}
	// set exists
	oe._exists = true
	return nil
}

// Update updates a OrganizationEvent in the database.
func (oe *OrganizationEvent) Update(ctx context.Context, db DB) error {
	switch {
	case !oe._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case oe._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.OrganizationEvents SET ` +
		`Name = $1, Latitude = $2, Longitude = $3, City = $4, State = $5, OrgFk = $6, Capacity = $7, Attending = $8, EventUuid = $9 ` +
		`WHERE OrganizationEventID = $10`
	// run
	logf(sqlstr, oe.Name, oe.Latitude, oe.Longitude, oe.City, oe.State, oe.OrgFk, oe.Capacity, oe.Attending, oe.EventUUID, oe.OrganizationEventID)
	if _, err := db.ExecContext(ctx, sqlstr, oe.Name, oe.Latitude, oe.Longitude, oe.City, oe.State, oe.OrgFk, oe.Capacity, oe.Attending, oe.EventUUID, oe.OrganizationEventID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the OrganizationEvent to the database.
func (oe *OrganizationEvent) Save(ctx context.Context, db DB) error {
	if oe.Exists() {
		return oe.Update(ctx, db)
	}
	return oe.Insert(ctx, db)
}

// Upsert performs an upsert for OrganizationEvent.
func (oe *OrganizationEvent) Upsert(ctx context.Context, db DB) error {
	switch {
	case oe._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.OrganizationEvents (` +
		`OrganizationEventID, Name, Latitude, Longitude, City, State, OrgFk, Capacity, Attending, EventUuid` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (OrganizationEventID) DO ` +
		`UPDATE SET ` +
		`Name = EXCLUDED.Name, Latitude = EXCLUDED.Latitude, Longitude = EXCLUDED.Longitude, City = EXCLUDED.City, State = EXCLUDED.State, OrgFk = EXCLUDED.OrgFk, Capacity = EXCLUDED.Capacity, Attending = EXCLUDED.Attending, EventUuid = EXCLUDED.EventUuid `
	// run
	logf(sqlstr, oe.OrganizationEventID, oe.Name, oe.Latitude, oe.Longitude, oe.City, oe.State, oe.OrgFk, oe.Capacity, oe.Attending, oe.EventUUID)
	if _, err := db.ExecContext(ctx, sqlstr, oe.OrganizationEventID, oe.Name, oe.Latitude, oe.Longitude, oe.City, oe.State, oe.OrgFk, oe.Capacity, oe.Attending, oe.EventUUID); err != nil {
		return logerror(err)
	}
	// set exists
	oe._exists = true
	return nil
}

// Delete deletes the OrganizationEvent from the database.
func (oe *OrganizationEvent) Delete(ctx context.Context, db DB) error {
	switch {
	case !oe._exists: // doesn't exist
		return nil
	case oe._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.OrganizationEvents ` +
		`WHERE OrganizationEventID = $1`
	// run
	logf(sqlstr, oe.OrganizationEventID)
	if _, err := db.ExecContext(ctx, sqlstr, oe.OrganizationEventID); err != nil {
		return logerror(err)
	}
	// set deleted
	oe._deleted = true
	return nil
}

// OrganizationEventByEventUUID retrieves a row from 'public.OrganizationEvents' as a OrganizationEvent.
//
// Generated from index 'OrganizationEventIndex'.
func OrganizationEventByEventUUID(ctx context.Context, db DB, eventUUID string) (*OrganizationEvent, error) {
	// query
	const sqlstr = `SELECT ` +
		`OrganizationEventID, Name, Latitude, Longitude, City, State, OrgFk, Capacity, Attending, EventUuid ` +
		`FROM public.OrganizationEvents ` +
		`WHERE EventUuid = $1`
	// run
	logf(sqlstr, eventUUID)
	oe := OrganizationEvent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, eventUUID).Scan(&oe.OrganizationEventID, &oe.Name, &oe.Latitude, &oe.Longitude, &oe.City, &oe.State, &oe.OrgFk, &oe.Capacity, &oe.Attending, &oe.EventUUID); err != nil {
		return nil, logerror(err)
	}
	return &oe, nil
}

// OrganizationEventByOrganizationEventID retrieves a row from 'public.OrganizationEvents' as a OrganizationEvent.
//
// Generated from index 'OrganizationEvents_pkey'.
func OrganizationEventByOrganizationEventID(ctx context.Context, db DB, organizationEventID int) (*OrganizationEvent, error) {
	// query
	const sqlstr = `SELECT ` +
		`OrganizationEventID, Name, Latitude, Longitude, City, State, OrgFk, Capacity, Attending, EventUuid ` +
		`FROM public.OrganizationEvents ` +
		`WHERE OrganizationEventID = $1`
	// run
	logf(sqlstr, organizationEventID)
	oe := OrganizationEvent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, organizationEventID).Scan(&oe.OrganizationEventID, &oe.Name, &oe.Latitude, &oe.Longitude, &oe.City, &oe.State, &oe.OrgFk, &oe.Capacity, &oe.Attending, &oe.EventUUID); err != nil {
		return nil, logerror(err)
	}
	return &oe, nil
}

// Organization returns the Organization associated with the OrganizationEvent's (OrgFk).
//
// Generated from foreign key 'OrganizationEvents_OrgFk_fkey'.
func (oe *OrganizationEvent) Organization(ctx context.Context, db DB) (*Organization, error) {
	return OrganizationByOrganizationID(ctx, db, oe.OrgFk)
}
