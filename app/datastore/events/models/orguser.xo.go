package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// Orguser represents a row from 'public.orgusers'.
type Orguser struct {
	Orguserid       int `json:"orguserid"`       // orguserid
	Permissionscode int `json:"permissionscode"` // permissionscode
	Userfk          int `json:"userfk"`          // userfk
	Orgfk           int `json:"orgfk"`           // orgfk
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Orguser exists in the database.
func (o *Orguser) Exists() bool {
	return o._exists
}

// Deleted returns true when the Orguser has been marked for deletion from
// the database.
func (o *Orguser) Deleted() bool {
	return o._deleted
}

// Insert inserts the Orguser to the database.
func (o *Orguser) Insert(ctx context.Context, db DB) error {
	switch {
	case o._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case o._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.orgusers (` +
		`permissionscode, userfk, orgfk` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING orguserid`
	// run
	logf(sqlstr, o.Permissionscode, o.Userfk, o.Orgfk)
	if err := db.QueryRowContext(ctx, sqlstr, o.Permissionscode, o.Userfk, o.Orgfk).Scan(&o.Orguserid); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Update updates a Orguser in the database.
func (o *Orguser) Update(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case o._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.orgusers SET ` +
		`permissionscode = $1, userfk = $2, orgfk = $3 ` +
		`WHERE orguserid = $4`
	// run
	logf(sqlstr, o.Permissionscode, o.Userfk, o.Orgfk, o.Orguserid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Permissionscode, o.Userfk, o.Orgfk, o.Orguserid); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Orguser to the database.
func (o *Orguser) Save(ctx context.Context, db DB) error {
	if o.Exists() {
		return o.Update(ctx, db)
	}
	return o.Insert(ctx, db)
}

// Upsert performs an upsert for Orguser.
func (o *Orguser) Upsert(ctx context.Context, db DB) error {
	switch {
	case o._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.orgusers (` +
		`orguserid, permissionscode, userfk, orgfk` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (orguserid) DO ` +
		`UPDATE SET ` +
		`permissionscode = EXCLUDED.permissionscode, userfk = EXCLUDED.userfk, orgfk = EXCLUDED.orgfk `
	// run
	logf(sqlstr, o.Orguserid, o.Permissionscode, o.Userfk, o.Orgfk)
	if _, err := db.ExecContext(ctx, sqlstr, o.Orguserid, o.Permissionscode, o.Userfk, o.Orgfk); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Delete deletes the Orguser from the database.
func (o *Orguser) Delete(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return nil
	case o._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.orgusers ` +
		`WHERE orguserid = $1`
	// run
	logf(sqlstr, o.Orguserid)
	if _, err := db.ExecContext(ctx, sqlstr, o.Orguserid); err != nil {
		return logerror(err)
	}
	// set deleted
	o._deleted = true
	return nil
}

// OrguserByOrguserid retrieves a row from 'public.orgusers' as a Orguser.
//
// Generated from index 'orgusers_pkey'.
func OrguserByOrguserid(ctx context.Context, db DB, orguserid int) (*Orguser, error) {
	// query
	const sqlstr = `SELECT ` +
		`orguserid, permissionscode, userfk, orgfk ` +
		`FROM public.orgusers ` +
		`WHERE orguserid = $1`
	// run
	logf(sqlstr, orguserid)
	o := Orguser{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, orguserid).Scan(&o.Orguserid, &o.Permissionscode, &o.Userfk, &o.Orgfk); err != nil {
		return nil, logerror(err)
	}
	return &o, nil
}

// Organization returns the Organization associated with the Orguser's (Orgfk).
//
// Generated from foreign key 'orgusers_orgfk_fkey'.
func (o *Orguser) Organization(ctx context.Context, db DB) (*Organization, error) {
	return OrganizationByOrganizationid(ctx, db, o.Orgfk)
}

// User returns the User associated with the Orguser's (Userfk).
//
// Generated from foreign key 'orgusers_userfk_fkey'.
func (o *Orguser) User(ctx context.Context, db DB) (*User, error) {
	return UserByUserid(ctx, db, o.Userfk)
}
