// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: queries.sql

package userRepo

import (
	"context"
	"encoding/json"
	"time"
)

const getEventById = `-- name: GetEventById :one
SELECT id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM events WHERE id = $1::int LIMIT 1
`

func (q *Queries) GetEventById(ctx context.Context, eventID int32) (*Event, error) {
	row := q.db.QueryRowContext(ctx, getEventById, eventID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventName,
		&i.EventDate,
		&i.EventLocation,
		&i.EventDescription,
		&i.Uuid,
		&i.EventImageUrl,
		&i.OrganizationFk,
	)
	return &i, err
}

const getEventByUuid = `-- name: GetEventByUuid :one
SELECT id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM events WHERE uuid = $1::text LIMIT 1
`

func (q *Queries) GetEventByUuid(ctx context.Context, eventUuid string) (*Event, error) {
	row := q.db.QueryRowContext(ctx, getEventByUuid, eventUuid)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventName,
		&i.EventDate,
		&i.EventLocation,
		&i.EventDescription,
		&i.Uuid,
		&i.EventImageUrl,
		&i.OrganizationFk,
	)
	return &i, err
}

const getEvents = `-- name: GetEvents :many
SELECT id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM events ORDER BY event_date DESC
`

func (q *Queries) GetEvents(ctx context.Context) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsOrderedByCreation = `-- name: GetEventsOrderedByCreation :many
SELECT id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM events ORDER BY id DESC
`

func (q *Queries) GetEventsOrderedByCreation(ctx context.Context) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsOrderedByCreation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationByUuid = `-- name: GetOrganizationByUuid :one
SELECT id, org_name, city, uuid, org_image_url FROM organizations WHERE uuid = $1::text LIMIT 1
`

func (q *Queries) GetOrganizationByUuid(ctx context.Context, organizationUuid string) (*Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByUuid, organizationUuid)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.OrgName,
		&i.City,
		&i.Uuid,
		&i.OrgImageUrl,
	)
	return &i, err
}

const getOrganizationEvents = `-- name: GetOrganizationEvents :many
SELECT e.id, event_name, event_date, event_location, event_description, e.uuid, event_image_url, organization_fk, o.id, org_name, city, o.uuid, org_image_url FROM events e INNER JOIN organizations o ON e.organization_fk = o.id WHERE o.uuid = $1::text
`

type GetOrganizationEventsRow struct {
	ID               int32
	EventName        string
	EventDate        time.Time
	EventLocation    string
	EventDescription string
	Uuid             string
	EventImageUrl    string
	OrganizationFk   int32
	ID_2             int32
	OrgName          string
	City             string
	Uuid_2           string
	OrgImageUrl      string
}

func (q *Queries) GetOrganizationEvents(ctx context.Context, orgUuid string) ([]*GetOrganizationEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationEvents, orgUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrganizationEventsRow
	for rows.Next() {
		var i GetOrganizationEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
			&i.ID_2,
			&i.OrgName,
			&i.City,
			&i.Uuid_2,
			&i.OrgImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token FROM users WHERE email = $1::text LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.PasswordHash,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.ImageUrl,
		&i.Validated,
		&i.RefreshToken,
	)
	return &i, err
}

const getUserByUuid = `-- name: GetUserByUuid :one

SELECT id, uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token FROM users WHERE uuid = $1::text LIMIT 1
`

// GETS
func (q *Queries) GetUserByUuid(ctx context.Context, uuid string) (*User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUuid, uuid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.PasswordHash,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.ImageUrl,
		&i.Validated,
		&i.RefreshToken,
	)
	return &i, err
}

const getUserEvents = `-- name: GetUserEvents :many
SELECT ue.id, user_fk, event_fk, e.id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM user_events ue INNER JOIN events e ON ue.event_fk = e.id WHERE ue.user_fk = $1::int
`

type GetUserEventsRow struct {
	ID               int32
	UserFk           int32
	EventFk          int32
	ID_2             int32
	EventName        string
	EventDate        time.Time
	EventLocation    string
	EventDescription string
	Uuid             string
	EventImageUrl    string
	OrganizationFk   int32
}

func (q *Queries) GetUserEvents(ctx context.Context, userID int32) ([]*GetUserEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserEventsRow
	for rows.Next() {
		var i GetUserEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserFk,
			&i.EventFk,
			&i.ID_2,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrgUserJoin = `-- name: GetUserOrgUserJoin :one
SELECT u.id, uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token, o.id, policies_num, user_fk, organization_fk FROM users u INNER JOIN org_users o ON u.id = o.user_fk WHERE u.uuid = $1::text LIMIT 1
`

type GetUserOrgUserJoinRow struct {
	ID             int32
	Uuid           string
	Email          string
	PasswordHash   string
	PhoneNumber    string
	FirstName      string
	LastName       string
	ImageUrl       string
	Validated      bool
	RefreshToken   string
	ID_2           int32
	PoliciesNum    int32
	UserFk         int32
	OrganizationFk int32
}

func (q *Queries) GetUserOrgUserJoin(ctx context.Context, uuid string) (*GetUserOrgUserJoinRow, error) {
	row := q.db.QueryRowContext(ctx, getUserOrgUserJoin, uuid)
	var i GetUserOrgUserJoinRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.PasswordHash,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.ImageUrl,
		&i.Validated,
		&i.RefreshToken,
		&i.ID_2,
		&i.PoliciesNum,
		&i.UserFk,
		&i.OrganizationFk,
	)
	return &i, err
}

const getUserOrganizations = `-- name: GetUserOrganizations :many
SELECT ou.id, policies_num, user_fk, organization_fk, og.id, org_name, city, uuid, org_image_url FROM org_users ou INNER JOIN organizations og ON ou.organization_fk = og.id WHERE ou.user_fk = $1::int
`

type GetUserOrganizationsRow struct {
	ID             int32
	PoliciesNum    int32
	UserFk         int32
	OrganizationFk int32
	ID_2           int32
	OrgName        string
	City           string
	Uuid           string
	OrgImageUrl    string
}

func (q *Queries) GetUserOrganizations(ctx context.Context, userID int32) ([]*GetUserOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserOrganizationsRow
	for rows.Next() {
		var i GetUserOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PoliciesNum,
			&i.UserFk,
			&i.OrganizationFk,
			&i.ID_2,
			&i.OrgName,
			&i.City,
			&i.Uuid,
			&i.OrgImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEvent = `-- name: InsertEvent :exec
INSERT INTO events (event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type InsertEventParams struct {
	EventName        string
	EventDate        time.Time
	EventLocation    string
	EventDescription string
	Uuid             string
	EventImageUrl    string
	OrganizationFk   int32
}

func (q *Queries) InsertEvent(ctx context.Context, arg *InsertEventParams) error {
	_, err := q.db.ExecContext(ctx, insertEvent,
		arg.EventName,
		arg.EventDate,
		arg.EventLocation,
		arg.EventDescription,
		arg.Uuid,
		arg.EventImageUrl,
		arg.OrganizationFk,
	)
	return err
}

const insertInvite = `-- name: InsertInvite :exec
INSERT INTO invites (expiration_date, use_limit, policy_json, uuid) VALUES ($1, $2, $3, $4)
`

type InsertInviteParams struct {
	ExpirationDate time.Time
	UseLimit       int32
	PolicyJson     json.RawMessage
	Uuid           string
}

func (q *Queries) InsertInvite(ctx context.Context, arg *InsertInviteParams) error {
	_, err := q.db.ExecContext(ctx, insertInvite,
		arg.ExpirationDate,
		arg.UseLimit,
		arg.PolicyJson,
		arg.Uuid,
	)
	return err
}

const insertOrgUser = `-- name: InsertOrgUser :exec
INSERT INTO org_users (policies_num, user_fk, organization_fk) VALUES ($1,$2,$3)
`

type InsertOrgUserParams struct {
	PoliciesNum    int32
	UserFk         int32
	OrganizationFk int32
}

func (q *Queries) InsertOrgUser(ctx context.Context, arg *InsertOrgUserParams) error {
	_, err := q.db.ExecContext(ctx, insertOrgUser, arg.PoliciesNum, arg.UserFk, arg.OrganizationFk)
	return err
}

const insertOrganization = `-- name: InsertOrganization :exec
INSERT INTO organizations (org_name, city, uuid, org_image_url) VALUES ($1,$2,$3,$4)
`

type InsertOrganizationParams struct {
	OrgName     string
	City        string
	Uuid        string
	OrgImageUrl string
}

func (q *Queries) InsertOrganization(ctx context.Context, arg *InsertOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, insertOrganization,
		arg.OrgName,
		arg.City,
		arg.Uuid,
		arg.OrgImageUrl,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec

INSERT INTO users (uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
`

type InsertUserParams struct {
	Uuid         string
	Email        string
	PasswordHash string
	PhoneNumber  string
	FirstName    string
	LastName     string
	ImageUrl     string
	Validated    bool
	RefreshToken string
}

// PUTS
func (q *Queries) InsertUser(ctx context.Context, arg *InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser,
		arg.Uuid,
		arg.Email,
		arg.PasswordHash,
		arg.PhoneNumber,
		arg.FirstName,
		arg.LastName,
		arg.ImageUrl,
		arg.Validated,
		arg.RefreshToken,
	)
	return err
}

const truncateAll = `-- name: TruncateAll :exec

TRUNCATE users, org_users, organizations, events, user_events, event_applications, invites
`

// UTIL
func (q *Queries) TruncateAll(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateAll)
	return err
}
