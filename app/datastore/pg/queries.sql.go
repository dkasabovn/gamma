// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: queries.sql

package userRepo

import (
	"context"
	"database/sql"
	"time"
)

const getEvent = `-- name: GetEvent :one
SELECT id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM events e WHERE uuid = $1
`

func (q *Queries) GetEvent(ctx context.Context, uuid string) (*Event, error) {
	row := q.db.QueryRowContext(ctx, getEvent, uuid)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventName,
		&i.EventDate,
		&i.EventLocation,
		&i.EventDescription,
		&i.Uuid,
		&i.EventImageUrl,
		&i.OrganizationFk,
	)
	return &i, err
}

const getEvents = `-- name: GetEvents :many
SELECT e.id, event_name, event_date, event_location, event_description, e.uuid, event_image_url, organization_fk, o.id, org_name, city, o.uuid, org_image_url, ue.id, user_fk, event_fk, application_state FROM events e
    INNER JOIN organizations o ON o.id = e.organization_fk 
    LEFT JOIN user_events ue ON e.id = ue.event_fk
    WHERE event_date > NOW() AND ue.user_fk = $1::int ORDER BY event_date - NOW() ASC LIMIT 50
`

type GetEventsRow struct {
	ID               int32
	EventName        string
	EventDate        time.Time
	EventLocation    string
	EventDescription string
	Uuid             string
	EventImageUrl    string
	OrganizationFk   int32
	ID_2             int32
	OrgName          string
	City             string
	Uuid_2           string
	OrgImageUrl      string
	ID_3             sql.NullInt32
	UserFk           sql.NullInt32
	EventFk          sql.NullInt32
	ApplicationState sql.NullString
}

func (q *Queries) GetEvents(ctx context.Context, userID int32) ([]*GetEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetEventsRow
	for rows.Next() {
		var i GetEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
			&i.ID_2,
			&i.OrgName,
			&i.City,
			&i.Uuid_2,
			&i.OrgImageUrl,
			&i.ID_3,
			&i.UserFk,
			&i.EventFk,
			&i.ApplicationState,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvite = `-- name: GetInvite :one
SELECT id, expiration_date, capacity, uuid, org_user_fk, entity_uuid, entity_type FROM invites i WHERE uuid = $1
`

func (q *Queries) GetInvite(ctx context.Context, uuid string) (*Invite, error) {
	row := q.db.QueryRowContext(ctx, getInvite, uuid)
	var i Invite
	err := row.Scan(
		&i.ID,
		&i.ExpirationDate,
		&i.Capacity,
		&i.Uuid,
		&i.OrgUserFk,
		&i.EntityUuid,
		&i.EntityType,
	)
	return &i, err
}

const getOrgUser = `-- name: GetOrgUser :one
WITH org_id AS (
	SELECT id FROM organizations o WHERE o.uuid = $2::text
) SELECT u.id, uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token, o.id, policies_num, user_fk, organization_fk FROM users u INNER JOIN org_users o ON u.id = o.user_fk WHERE o.organization_fk = (SELECT id FROM org_id LIMIT 1) AND u.uuid = $1
`

type GetOrgUserParams struct {
	UserUuid string
	OrgUuid  string
}

type GetOrgUserRow struct {
	ID             int32
	Uuid           string
	Email          string
	PasswordHash   string
	PhoneNumber    string
	FirstName      string
	LastName       string
	ImageUrl       string
	Validated      bool
	RefreshToken   string
	ID_2           int32
	PoliciesNum    int32
	UserFk         int32
	OrganizationFk int32
}

func (q *Queries) GetOrgUser(ctx context.Context, arg *GetOrgUserParams) (*GetOrgUserRow, error) {
	row := q.db.QueryRowContext(ctx, getOrgUser, arg.UserUuid, arg.OrgUuid)
	var i GetOrgUserRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.PasswordHash,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.ImageUrl,
		&i.Validated,
		&i.RefreshToken,
		&i.ID_2,
		&i.PoliciesNum,
		&i.UserFk,
		&i.OrganizationFk,
	)
	return &i, err
}

const getOrgUserInvites = `-- name: GetOrgUserInvites :many
SELECT id, expiration_date, capacity, uuid, org_user_fk, entity_uuid, entity_type FROM invites i WHERE org_user_fk = $1 AND entity_uuid = $2
`

type GetOrgUserInvitesParams struct {
	OrgUserFk  int32
	EntityUuid string
}

func (q *Queries) GetOrgUserInvites(ctx context.Context, arg *GetOrgUserInvitesParams) ([]*Invite, error) {
	rows, err := q.db.QueryContext(ctx, getOrgUserInvites, arg.OrgUserFk, arg.EntityUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Invite
	for rows.Next() {
		var i Invite
		if err := rows.Scan(
			&i.ID,
			&i.ExpirationDate,
			&i.Capacity,
			&i.Uuid,
			&i.OrgUserFk,
			&i.EntityUuid,
			&i.EntityType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, org_name, city, uuid, org_image_url FROM organizations o WHERE uuid = $1
`

func (q *Queries) GetOrganization(ctx context.Context, uuid string) (*Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganization, uuid)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.OrgName,
		&i.City,
		&i.Uuid,
		&i.OrgImageUrl,
	)
	return &i, err
}

const getOrganizationByUuid = `-- name: GetOrganizationByUuid :one
SELECT id, org_name, city, uuid, org_image_url FROM organizations WHERE uuid = $1::text LIMIT 1
`

func (q *Queries) GetOrganizationByUuid(ctx context.Context, organizationUuid string) (*Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByUuid, organizationUuid)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.OrgName,
		&i.City,
		&i.Uuid,
		&i.OrgImageUrl,
	)
	return &i, err
}

const getOrganizationEvents = `-- name: GetOrganizationEvents :many
SELECT e.id, e.event_name, e.event_date, e.event_location, e.event_description, e.uuid, e.event_image_url, e.organization_fk FROM events e INNER JOIN organizations o ON e.organization_fk = o.id WHERE o.uuid = $1::text
`

func (q *Queries) GetOrganizationEvents(ctx context.Context, orgUuid string) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationEvents, orgUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token FROM users WHERE email = $1::text LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.PasswordHash,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.ImageUrl,
		&i.Validated,
		&i.RefreshToken,
	)
	return &i, err
}

const getUserByUuid = `-- name: GetUserByUuid :one

SELECT id, uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token FROM users WHERE uuid = $1::text LIMIT 1
`

// GETS
func (q *Queries) GetUserByUuid(ctx context.Context, uuid string) (*User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUuid, uuid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.PasswordHash,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.ImageUrl,
		&i.Validated,
		&i.RefreshToken,
	)
	return &i, err
}

const getUserEvents = `-- name: GetUserEvents :many
SELECT ue.id, user_fk, event_fk, application_state, e.id, event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk FROM user_events ue INNER JOIN events e ON ue.event_fk = e.id WHERE ue.user_fk = $1::int
`

type GetUserEventsRow struct {
	ID               int32
	UserFk           int32
	EventFk          int32
	ApplicationState string
	ID_2             int32
	EventName        string
	EventDate        time.Time
	EventLocation    string
	EventDescription string
	Uuid             string
	EventImageUrl    string
	OrganizationFk   int32
}

func (q *Queries) GetUserEvents(ctx context.Context, userID int32) ([]*GetUserEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserEventsRow
	for rows.Next() {
		var i GetUserEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserFk,
			&i.EventFk,
			&i.ApplicationState,
			&i.ID_2,
			&i.EventName,
			&i.EventDate,
			&i.EventLocation,
			&i.EventDescription,
			&i.Uuid,
			&i.EventImageUrl,
			&i.OrganizationFk,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrganizations = `-- name: GetUserOrganizations :many
SELECT ou.id, policies_num, user_fk, organization_fk, og.id, org_name, city, uuid, org_image_url FROM org_users ou INNER JOIN organizations og ON ou.organization_fk = og.id WHERE ou.user_fk = $1::int
`

type GetUserOrganizationsRow struct {
	ID             int32
	PoliciesNum    int32
	UserFk         int32
	OrganizationFk int32
	ID_2           int32
	OrgName        string
	City           string
	Uuid           string
	OrgImageUrl    string
}

func (q *Queries) GetUserOrganizations(ctx context.Context, userID int32) ([]*GetUserOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserOrganizationsRow
	for rows.Next() {
		var i GetUserOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PoliciesNum,
			&i.UserFk,
			&i.OrganizationFk,
			&i.ID_2,
			&i.OrgName,
			&i.City,
			&i.Uuid,
			&i.OrgImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEvent = `-- name: InsertEvent :exec
INSERT INTO events (event_name, event_date, event_location, event_description, uuid, event_image_url, organization_fk) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type InsertEventParams struct {
	EventName        string
	EventDate        time.Time
	EventLocation    string
	EventDescription string
	Uuid             string
	EventImageUrl    string
	OrganizationFk   int32
}

func (q *Queries) InsertEvent(ctx context.Context, arg *InsertEventParams) error {
	_, err := q.db.ExecContext(ctx, insertEvent,
		arg.EventName,
		arg.EventDate,
		arg.EventLocation,
		arg.EventDescription,
		arg.Uuid,
		arg.EventImageUrl,
		arg.OrganizationFk,
	)
	return err
}

const insertInvite = `-- name: InsertInvite :exec
INSERT INTO invites (expiration_date, capacity, uuid, org_user_fk, entity_uuid, entity_type) VALUES ($1,$2,$3,$4,$5,$6)
`

type InsertInviteParams struct {
	ExpirationDate time.Time
	Capacity       int32
	Uuid           string
	OrgUserFk      int32
	EntityUuid     string
	EntityType     int32
}

func (q *Queries) InsertInvite(ctx context.Context, arg *InsertInviteParams) error {
	_, err := q.db.ExecContext(ctx, insertInvite,
		arg.ExpirationDate,
		arg.Capacity,
		arg.Uuid,
		arg.OrgUserFk,
		arg.EntityUuid,
		arg.EntityType,
	)
	return err
}

const insertOrgUser = `-- name: InsertOrgUser :exec
INSERT INTO org_users (policies_num, user_fk, organization_fk) VALUES ($1,$2,$3)
`

type InsertOrgUserParams struct {
	PoliciesNum    int32
	UserFk         int32
	OrganizationFk int32
}

func (q *Queries) InsertOrgUser(ctx context.Context, arg *InsertOrgUserParams) error {
	_, err := q.db.ExecContext(ctx, insertOrgUser, arg.PoliciesNum, arg.UserFk, arg.OrganizationFk)
	return err
}

const insertOrganization = `-- name: InsertOrganization :one
INSERT INTO organizations (org_name, city, uuid, org_image_url) VALUES ($1,$2,$3,$4) RETURNING id
`

type InsertOrganizationParams struct {
	OrgName     string
	City        string
	Uuid        string
	OrgImageUrl string
}

func (q *Queries) InsertOrganization(ctx context.Context, arg *InsertOrganizationParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertOrganization,
		arg.OrgName,
		arg.City,
		arg.Uuid,
		arg.OrgImageUrl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertUser = `-- name: InsertUser :exec

INSERT INTO users (uuid, email, password_hash, phone_number, first_name, last_name, image_url, validated, refresh_token) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
`

type InsertUserParams struct {
	Uuid         string
	Email        string
	PasswordHash string
	PhoneNumber  string
	FirstName    string
	LastName     string
	ImageUrl     string
	Validated    bool
	RefreshToken string
}

// PUTS
func (q *Queries) InsertUser(ctx context.Context, arg *InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser,
		arg.Uuid,
		arg.Email,
		arg.PasswordHash,
		arg.PhoneNumber,
		arg.FirstName,
		arg.LastName,
		arg.ImageUrl,
		arg.Validated,
		arg.RefreshToken,
	)
	return err
}

const truncateAll = `-- name: TruncateAll :exec

TRUNCATE users, org_users, organizations, events, user_events, invites
`

// UTIL
func (q *Queries) TruncateAll(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateAll)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET first_name = $2, last_name = $3, email = $4, phone_number = $5, password_hash = $6, image_url = $7 WHERE uuid = $1
`

type UpdateUserParams struct {
	Uuid         string
	FirstName    string
	LastName     string
	Email        string
	PhoneNumber  string
	PasswordHash string
	ImageUrl     string
}

func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Uuid,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.PhoneNumber,
		arg.PasswordHash,
		arg.ImageUrl,
	)
	return err
}
